# Detailed Program of the Workshop

## Introductions: Who's In the Room

* And who are you? Quick word about the lab and what we do in Lyon

## Quick Faust Demo in the IDE

* First sawtooth example with a UI
* Then make it poly/MIDI
* Call library element:

```
import("stdfaust.lib");
process = ba.pulsen(1, 10000) : pm.djembe(60, 0.3, 0.4, 1) <: dm.freeverb_demo;
```

## Where Does Faust Stand As a Programming Language?

* What's a functional language?
* Why is it different?
* Where is Faust compared to other languages

## Tour of the Faust Targets 

## Where to Get Faust?

* GitHub and talk about documentation as well

## Gain Control

## Exercise: Implement a Panner

## Exercise: Make the Panner Automatic and Implement Ring Modulation

## Delays

## One Zero Filter

## Generic FIR

```
fir((b0,bv))
```

## FF Comb

## Exercise: Flanger

## Tilde Operator

## Towards Implementing an Oscillator

Make it an exercise!

```
import("stdfaust.lib");
f = hslider("freq",440,50,2000,0.01);
phasor(freq) = (+(freq/ma.SR) ~ ma.frac);
osc(freq) = sin(phasor(freq)*2*ma.PI);
process = osc(f);
```

## Exercise: AM 

## Exercise: FM

## One Pole

## Exercise: Smoothing Filter

## Biquad Section

```
y(n) = x(n) + b1*x(n-1) + b2*x(n-2) - a1*y(n-1) - a2*y(n-2)
```

In Faust implemented in `fi.tf2` which basically corresponds to:

```
tf2(b0,b1,b2,a1,a2) = iir((b0,b1,b2),(a1,a2));
```

`fi.tf2s` is the bilinear transform version

## Resonant Filters

## Peak Equalizer

```
_ : peak_eq(Lfx,fx,B) : _
```

Where:

* `Lfx`: level (dB) at fx (boost Lfx>0 or cut Lfx<0)
* `fx`: peak frequency (Hz)
* `B`: bandwidth (B) of peak in Hz

## Exercise: Implementing a Peak Equalizer

## Advanced Faust Concepts

### Creating Conditions

### Creating Iterations

### Pattern Matching

* First start with a basic example of creating an array and then show how to implement an FIR filter from scratch:

```
import("stdfaust.lib");

fir((b0,bv)) = _ <: *(b0), R(1,bv) :> _ with {
	R(n,(bn,bv)) = (@(n):*(bn)), R(n+1,bv);
	R(n, bn)     = (@(n):*(bn)); };
fir(b0) = *(b0);

process = fir((0.9));
```

### Briefly Show a Letrec Example

```
onePole(a1,x) = y
letrec{
    'y = x + y*a1;
};
```

Food for thoughts: try to implement a biquad filter using this approach.

## Tour of `filters.lib`

## Using Faust at a Lower Level

### Generating C++ Code With Faust

and tuning the code generated by the compiler, etc.

### Integrating Faust Objects to a JUCE Plugin

<https://faustdoc.grame.fr/workshops/2020-04-10-faust-juce/>

### Integrating Faust Objects to Android Apps

<https://ccrma.stanford.edu/~rmichon/faustTutorials/#adding-faust-real-time-audio-support-to-ios-apps>

(even though in the case of the workshop it might make more sense to generate Android apps using `faust2android`)
